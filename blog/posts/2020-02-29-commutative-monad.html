<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Too lazy to evaluate - 可換なモナドとは？</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Too lazy to evaluate</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>可換なモナドとは？</h1>
            <article>
    <section class="header">
        Posted on February 29, 2020
        
    </section>
    <section>
        <h2 id="listtの醜名"><code>ListT</code>の醜名</h2>
<p>よく知られた話として、モナド変換子 <code>ListT</code>（<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-List.html#t:ListT">ドキュメント</a>） が<code>Monad</code>則を満たしていないという話があります。</p>
<p><code>ListT</code>は、あまり本質的でない部分を除くと、以下のように定義されています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> runListT ::</span> m [a] }</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">ListT</span> m) <span class="kw">where</span> <span class="co">{- 省略 -}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ListT</span> m) <span class="kw">where</span> <span class="co">{- 省略 -}</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ListT</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">ListT</span> <span class="fu">$</span> <span class="fu">return</span> [a]</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="dt">ListT</span> mta <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">ListT</span> <span class="fu">$</span> <span class="fu">fmap</span> <span class="fu">concat</span> <span class="fu">$</span> mta <span class="fu">&gt;&gt;=</span> <span class="fu">traverse</span> (runListT <span class="fu">.</span> f)</a></code></pre></div>
<p>しかし、<code>instance Monad m =&gt; Monad (ListT m)</code> は正当なインスタンスではありません。 どんな <code>m</code> に対しても<code>ListT m</code>が真にMonadである―Monad則を満たす―わけではないからです。 （そのため、<code>Control.Monad.List</code>はモジュール全体がdeprecatedです。）</p>
<p>Monadとして破綻していることを実際に示すことも簡単にできます。</p>
<pre><code>&gt;&gt;&gt; import Control.Monad.List
&gt;&gt;&gt; :set -Wno-deprecations
&gt;&gt;&gt; :{
    purr :: String -&gt; ListT IO ()
    purr str = ListT (putStr str &gt;&gt; return [(), ()]) 
    :}
&gt;&gt;&gt; runListT $ purr &quot;a&quot; &gt;&gt; (purr &quot;b&quot; &gt;&gt; purr &quot;c&quot;)
abccbcc[(),(),(),(),(),(),(),()]
&gt;&gt;&gt; runListT $ (purr &quot;a&quot; &gt;&gt; purr &quot;b&quot;) &gt;&gt; purr &quot;c&quot;
abbcccc[(),(),(),(),(),(),(),()]</code></pre>
<p>副作用として出力された文字の順番に注目してください。カッコを付け替えただけなのに順番が違いますね？ Monad則の一つ、結合法則を満たしていません。</p>
<p>さて、<code>ListT</code>のドキュメントにはこんなことが書かれています。</p>
<blockquote>
<p><em>Note:</em> this does not yield a monad unless the argument monad is commutative.</p>
<p><em>注意:</em> 引数のモナドが可換でない限り、これはMonadにはならない。</p>
</blockquote>
<p>裏を返せば、「引数のモナド<code>m</code>が可換なときに限り、<code>ListT m</code>はMonadになる」ということです。</p>
<p>さて、「モナドが可換である」って、聞いたことあります？私は、「なんとなく言いたいことはわかるけど、 ちょっと曖昧じゃない？」と感じていました。例えば、ある2項演算<code>op :: (X, X) -&gt; X</code>が可換であると言うとき、ふつうは</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">swap ::</span> (x, y) <span class="ot">-&gt;</span> (y, x)</a>
<a class="sourceLine" id="cb3-2" title="2">swap (x, y) <span class="fu">=</span> (y, x)</a></code></pre></div>
<p>のように、“引数の順番を入れ替える”写像を使って、<code>op . swap = op</code>のように定義します。しかし、<code>Monad</code>の“2項演算”は <code>join :: forall a. m (m a) -&gt; m a</code>です。この“引数の順番を入れ替える”ことは、一般にはできません。 では、Monadが可換であるという条件は、どう定義すればいいのでしょうか？</p>
<h2 id="可換なモナド-とは">可換なモナド #とは</h2>
<p>ググってみましょう。</p>
<ul>
<li><p><a href="https://wiki.haskell.org/Monad#Commutative_monads">HaskellWikiでの定義</a></p>
<p><code>Monad m</code>が可換であるとは、任意の<code>actA :: m a, actB :: m b, m :: a -&gt; b -&gt; m c</code>に対して、 以下の等式が成り立つことを意味します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">do</span> { a <span class="ot">&lt;-</span> actA; b <span class="ot">&lt;-</span> actB; m a b }</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">do</span> { b <span class="ot">&lt;-</span> actB; a <span class="ot">&lt;-</span> actA; m a b }</a></code></pre></div>
<p>Monad則を使えば、これは「任意の<code>f :: a -&gt; b -&gt; c</code>に対して <code>liftM2 f actA actB = liftM2 (flip f) actB actA</code>」 と同値です。</p>
<p>どんなMonadも、その親クラスのApplicativeとの関係として、<code>liftA2 = liftM2</code>が要求されるため、 「<code>liftA2 f actA actB = liftA2 (flip f) actB actA</code>」とも同じことです。</p>
<p>これで、Monadが可換である条件は、<code>Applicative</code>の言葉だけで書けました。 標語的に、「<code>m</code>が可換であるとは、<code>Applicative</code>として可換である」とでも言いましょう。</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Strong_monad">Wikipedia</a></p>
<p>一般の（対称モノイダル）圏で考えるために色々書いてありますが、Haskellの<code>Monad</code>の場合だけを考えればそんなに難しいことは書いていないので、エイヤと翻訳してしまいます。</p>
<p><code>Monad</code>である<code>T</code>が可換であるとは、次の関数を使って・・・</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">left_strength ::</span> (a, <span class="dt">T</span> b) <span class="ot">-&gt;</span> <span class="dt">T</span> (a, b)</a>
<a class="sourceLine" id="cb5-2" title="2">left_strength (a, tb) <span class="fu">=</span> <span class="fu">fmap</span> (a, ) tb</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">right_strength ::</span> (<span class="dt">T</span> a, b) <span class="ot">-&gt;</span> <span class="dt">T</span> (a, b)</a>
<a class="sourceLine" id="cb5-5" title="5">right_strength <span class="fu">=</span> <span class="fu">fmap</span> swap <span class="fu">.</span> left_strength <span class="fu">.</span> swap</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="kw">where</span> swap (x, y) <span class="fu">=</span> (y, x)</a></code></pre></div>
<p>この等式が成り立つことをいいます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">join <span class="fu">.</span> <span class="fu">fmap</span> right_strength <span class="fu">.</span><span class="ot"> left_strength ::</span> (<span class="dt">T</span> a, <span class="dt">T</span> b) <span class="ot">-&gt;</span> <span class="dt">T</span> (a, b)</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" title="3">join <span class="fu">.</span> <span class="fu">fmap</span> left_strength <span class="fu">.</span><span class="ot"> right_strength ::</span> (<span class="dt">T</span> a, <span class="dt">T</span> b) <span class="ot">-&gt;</span> <span class="dt">T</span> (a, b)</a></code></pre></div>
<p>よくよく読めば、これもHaskellWikiの定義と同値だとわかります。実際、<code>=</code>の両辺をゴリゴリ変形すると、次のようにできます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">\(ta, tb) <span class="ot">-&gt;</span> <span class="kw">do</span> { b <span class="ot">&lt;-</span> tb; a <span class="ot">&lt;-</span> ta; <span class="fu">return</span> (a, b) }</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" title="3">\(ta, tb) <span class="ot">-&gt;</span> <span class="kw">do</span> { a <span class="ot">&lt;-</span> ta; b <span class="ot">&lt;-</span> tb; <span class="fu">return</span> (a, b) }</a></code></pre></div></li>
</ul>
<p>はい、これで「Monadが可換である」という言葉の意味が「Applicativeとして可換である」だったことがわかりました。</p>
<h2 id="証明しようモナドmが可換-listt-mがモナド則を満たす">証明しよう、「モナド<code>m</code>が可換」 ⇒ 「<code>ListT m</code>がモナド則を満たす」</h2>
<p>「モナド<code>m</code>が可換」 ⇒ 「<code>ListT m</code>がモナド則を満たす」は、実際に証明できるはずなので、やってみましょう。</p>
<p>次の2つのステップに分けて進めます。</p>
<ol type="1">
<li>「モナド<code>m</code>が可換」 ⇒ 「<code>join'</code>がApplicative準同型」</li>
<li>「<code>join'</code>がApplicative準同型」 ⇒ 「<code>ListT m</code>がモナド則を満たす」</li>
</ol>
<p>ここで、<code>join'</code>は、<code>m</code>の<code>Monad</code>を使って書かれる次の関数です。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">join' ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">forall</span> a<span class="fu">.</span> <span class="dt">Compose</span> m m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb8-2" title="2">join' <span class="fu">=</span> join <span class="fu">.</span> runCompose</a></code></pre></div>
<p><code>Compose</code>については<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html">Data.Functor.Compose</a>を参照して下さい。</p>
<p>Applicative準同型とは、<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Traversable.html#t:Traversable">Data.Traversable</a>のドキュメントでしか見たことがない、でもまあ、そうなるよねっていう感じのする、 Applicativeの間の自然変換です（いいかげん）。</p>
<blockquote>
<p>an <em>applicative transformation</em> is a function</p>
<p><code>t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a</code></p>
<p>preserving the Applicative operations, i.e.</p>
<ul>
<li><code>t (pure x) = pure x</code></li>
<li><code>t (x &lt;*&gt; y) = t x &lt;*&gt; t y</code></li>
</ul>
</blockquote>
<h3 id="モナドmが可換-joinがapplicative準同型">「モナド<code>m</code>が可換」 ⇒ 「<code>join'</code>がApplicative準同型」</h3>
<p><code>join'</code>が確かにApplicative準同型であることは、単に計算すれば出ます。</p>
<ol type="1">
<li><p><code>join' (pure x :: Compose m m a) = (pure x :: m a)</code></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">join' (<span class="fu">pure</span> x)</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="fu">=</span> join' <span class="fu">$</span> <span class="dt">Compose</span> (<span class="fu">pure</span> (<span class="fu">pure</span> x))</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="fu">=</span> join <span class="fu">.</span> runCompose <span class="fu">$</span> <span class="dt">Compose</span> <span class="fu">$</span> <span class="fu">pure</span> (<span class="fu">pure</span> x)</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="fu">=</span> join <span class="fu">$</span> <span class="fu">pure</span> (<span class="fu">pure</span> x)</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="co">-- pure = return に注意</span></a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="fu">=</span> <span class="fu">pure</span> x</a></code></pre></div></li>
<li><p><code>join' (x &lt;*&gt; y) = t x &lt;*&gt; t y</code></p>
<p><code>x = Compose mmf :: Compose m m (a -&gt; b), y = Compose mma :: Compose m m a</code>とおく。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">join' (<span class="dt">Compose</span> mmf <span class="fu">&lt;*&gt;</span> <span class="dt">Compose</span> mma)</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="fu">=</span> join' <span class="fu">$</span> <span class="dt">Compose</span> (liftA2 (<span class="fu">&lt;*&gt;</span>) mmf mma)</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="fu">=</span> join <span class="fu">.</span> runCompose <span class="fu">$</span> <span class="dt">Compose</span> (liftA2 (<span class="fu">&lt;*&gt;</span>) mmf mma)</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="fu">=</span> join <span class="fu">$</span> liftA2 (<span class="fu">&lt;*&gt;</span>) mmf mma</a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="co">-- liftA2 = liftM2, (&lt;*&gt;) = ap</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="fu">=</span> <span class="kw">do</span> mf <span class="ot">&lt;-</span> mmf</a>
<a class="sourceLine" id="cb10-7" title="7">       ma <span class="ot">&lt;-</span> mma</a>
<a class="sourceLine" id="cb10-8" title="8">       mf <span class="fu">&lt;*&gt;</span> ma</a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="fu">=</span> <span class="kw">do</span> mf <span class="ot">&lt;-</span> mmf</a>
<a class="sourceLine" id="cb10-10" title="10">       ma <span class="ot">&lt;-</span> mma</a>
<a class="sourceLine" id="cb10-11" title="11">       f <span class="ot">&lt;-</span> mf</a>
<a class="sourceLine" id="cb10-12" title="12">       a <span class="ot">&lt;-</span> ma</a>
<a class="sourceLine" id="cb10-13" title="13">       <span class="fu">return</span> (f a)</a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="co">-- m が可換であることを使う</span></a>
<a class="sourceLine" id="cb10-15" title="15">  <span class="fu">=</span> <span class="kw">do</span> mf <span class="ot">&lt;-</span> mmf</a>
<a class="sourceLine" id="cb10-16" title="16">       f <span class="ot">&lt;-</span> mf</a>
<a class="sourceLine" id="cb10-17" title="17">       ma <span class="ot">&lt;-</span> mma</a>
<a class="sourceLine" id="cb10-18" title="18">       a <span class="ot">&lt;-</span> ma</a>
<a class="sourceLine" id="cb10-19" title="19">       <span class="fu">return</span> (f a)</a>
<a class="sourceLine" id="cb10-20" title="20">  <span class="fu">=</span> <span class="kw">do</span> f <span class="ot">&lt;-</span> <span class="kw">do</span> { mf <span class="ot">&lt;-</span> mmf; mf }</a>
<a class="sourceLine" id="cb10-21" title="21">       a <span class="ot">&lt;-</span> <span class="kw">do</span> { ma <span class="ot">&lt;-</span> mma; ma }</a>
<a class="sourceLine" id="cb10-22" title="22">       <span class="fu">return</span> (f a)</a>
<a class="sourceLine" id="cb10-23" title="23">  <span class="fu">=</span> <span class="kw">do</span> f <span class="ot">&lt;-</span> join mmf</a>
<a class="sourceLine" id="cb10-24" title="24">       a <span class="ot">&lt;-</span> join mma</a>
<a class="sourceLine" id="cb10-25" title="25">       <span class="fu">return</span> (f a)</a>
<a class="sourceLine" id="cb10-26" title="26">  <span class="fu">=</span> join mmf <span class="fu">&lt;*&gt;</span> join mma</a>
<a class="sourceLine" id="cb10-27" title="27">  <span class="fu">=</span> join' (<span class="dt">Compose</span> mmf) <span class="fu">&lt;*&gt;</span> join' (<span class="dt">Compose</span> mma)</a></code></pre></div></li>
</ol>
<h2 id="joinがapplicative準同型-listt-mがモナド則を満たす">「<code>join'</code>がApplicative準同型」 ⇒ 「<code>ListT m</code>がモナド則を満たす」</h2>
<p><a href="./2020-02-29-commutative-monad-appendix.html">証明は長過ぎるので別のページに移しました。</a></p>
<h2 id="余談">余談</h2>
<p>余談ですが、上で示したことの逆も示せます。</p>
<ul>
<li>「モナド<code>m</code>が可換」 ⇐ 「<code>join'</code>がApplicative準同型」</li>
</ul>
<p>なので、「<code>join'</code>がApplicative準同型」も、「モナド<code>m</code>が可換」の定義として使えます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">ma ::</span> m a</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">mb ::</span> m b</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">mf <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span><span class="ot"> ma ::</span> m (b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">-- join'が準同型であることを使う</span></a>
<a class="sourceLine" id="cb11-8" title="8">join' <span class="fu">$</span> <span class="dt">Compose</span> (<span class="fu">pure</span> mf) <span class="fu">&lt;*&gt;</span> <span class="dt">Compose</span> (<span class="fu">fmap</span> <span class="fu">pure</span> mb)</a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="fu">=</span> join' (<span class="dt">Compose</span> (<span class="fu">pure</span> mf)) <span class="fu">&lt;*&gt;</span> join' (<span class="dt">Compose</span> (<span class="fu">fmap</span> <span class="fu">pure</span> mb))</a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="fu">=</span> join (<span class="fu">pure</span> mf) <span class="fu">&lt;*&gt;</span> join (<span class="fu">fmap</span> <span class="fu">pure</span> mb)</a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="fu">=</span> mf <span class="fu">&lt;*&gt;</span> mb</a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> ma <span class="fu">&lt;*&gt;</span> mb</a>
<a class="sourceLine" id="cb11-13" title="13">  <span class="fu">=</span> liftM2 f ma mb</a>
<a class="sourceLine" id="cb11-14" title="14"></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="co">-- Applicative (Compose m m) を使う</span></a>
<a class="sourceLine" id="cb11-16" title="16">join' <span class="fu">$</span> <span class="dt">Compose</span> (<span class="fu">pure</span> mf) <span class="fu">&lt;*&gt;</span> <span class="dt">Compose</span> (<span class="fu">fmap</span> <span class="fu">pure</span> mb)</a>
<a class="sourceLine" id="cb11-17" title="17">  <span class="fu">=</span> join' <span class="fu">$</span> <span class="dt">Compose</span> (liftA2 (<span class="fu">&lt;*&gt;</span>) (<span class="fu">pure</span> mf) (<span class="fu">fmap</span> <span class="fu">pure</span> mb))</a>
<a class="sourceLine" id="cb11-18" title="18">  <span class="fu">=</span> join <span class="fu">$</span> liftA2 (<span class="fu">&lt;*&gt;</span>) (<span class="fu">pure</span> mf) (<span class="fu">fmap</span> <span class="fu">pure</span> mb)</a>
<a class="sourceLine" id="cb11-19" title="19">  <span class="fu">=</span> join <span class="fu">$</span> <span class="fu">fmap</span> (mf <span class="fu">&lt;*&gt;</span>) (<span class="fu">fmap</span> <span class="fu">pure</span> mb)</a>
<a class="sourceLine" id="cb11-20" title="20">  <span class="fu">=</span> join <span class="fu">$</span> <span class="fu">fmap</span> (\b <span class="ot">-&gt;</span> mf <span class="fu">&lt;*&gt;</span> <span class="fu">pure</span> b) y</a>
<a class="sourceLine" id="cb11-21" title="21">  <span class="fu">=</span> join <span class="fu">$</span> <span class="fu">fmap</span> (\b <span class="ot">-&gt;</span> <span class="fu">fmap</span> (<span class="fu">$</span> b) mf) mb</a>
<a class="sourceLine" id="cb11-22" title="22">  <span class="fu">=</span> mb <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="fu">fmap</span> (<span class="fu">$</span> b) mf</a>
<a class="sourceLine" id="cb11-23" title="23">  <span class="fu">=</span> mb <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="fu">fmap</span> ((<span class="fu">$</span> b) <span class="fu">.</span> f) ma</a>
<a class="sourceLine" id="cb11-24" title="24">  <span class="fu">=</span> mb <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="fu">fmap</span> (<span class="fu">flip</span> f b) ma</a>
<a class="sourceLine" id="cb11-25" title="25">  <span class="fu">=</span> liftM2 (<span class="fu">flip</span> f) mb ma</a>
<a class="sourceLine" id="cb11-26" title="26"></a>
<a class="sourceLine" id="cb11-27" title="27"><span class="co">-- したがって、mは可換なモナドである。</span></a>
<a class="sourceLine" id="cb11-28" title="28">liftM2 f ma mb <span class="fu">=</span> liftM2 (<span class="fu">flip</span> f) mb ma</a></code></pre></div>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
