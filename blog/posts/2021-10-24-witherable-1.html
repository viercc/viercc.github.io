<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Too lazy to evaluate - FilterableとWitherableについて</title>
        
          <!-- KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.20/dist/katex.min.css" integrity="sha384-sMefv1J1YJCHsg0mTa9YG+n/9KnJb9lGrJUUY5arg6bAL1qps/oZjmUwaHlX5Ugg" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.20/dist/katex.min.js" integrity="sha384-i9p+YmlwbK0lT9RcfgdAo/Cikui1KeFMeV/0Fwsu+rzgsCvas6oUptNOmo29C33p" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="../js/katex-render-hook.js"></script>

        
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="icon" type="image/vnd.microsoft.icon" sizes="16x16" href="../favicon.ico" />
        <link rel="icon" type="image/png" sizes="96x96" href="../favicon96.png" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Too lazy to evaluate</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <a href="../pdfs.html">PDFs</a>
                <a href="../softwares.html">Softwares</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>FilterableとWitherableについて</h1>
            <article>
    <section class="header">
        <ul class="metadata_display_list">
            
                <li>Posted on 2021-11-13</li>
            
            
                <li>Last modified on 2025-02-22</li>
            
            
            
                <li class="post-tags">tags: <a title="All pages tagged 'witherable'." href="../tags/witherable.html" rel="tag">witherable</a>, <a title="All pages tagged 'string-diagram'." href="../tags/string-diagram.html" rel="tag">string-diagram</a></li>
            
        </ul>
    </section>
    <section>
        <div id="post-toc">目次<ul>
<li><a href="#まえがき" id="toc-まえがき">まえがき</a></li>
<li><a href="#filterableとwitherable" id="toc-filterableとwitherable"><code>Filterable</code>と<code>Witherable</code></a>
<ul>
<li><a href="#filterableの概要" id="toc-filterableの概要"><code>Filterable</code>の概要</a></li>
<li><a href="#witherableの概要" id="toc-witherableの概要"><code>Witherable</code>の概要</a></li>
</ul></li>
<li><a href="#traversableのおさらい" id="toc-traversableのおさらい"><code>Traversable</code>のおさらい</a></li>
<li><a href="#filterableの理論" id="toc-filterableの理論"><code>Filterable</code>の理論</a>
<ul>
<li><a href="#脱法filterable" id="toc-脱法filterable">脱法<code>Filterable</code></a></li>
</ul></li>
<li><a href="#witherableの理論" id="toc-witherableの理論"><code>Witherable</code>の理論</a></li>
<li><a href="#witherable-は-filterabletraversable-ではない" id="toc-witherable-は-filterabletraversable-ではない">Witherable は Filterable+Traversable ではない</a></li>
<li><a href="#結論" id="toc-結論">結論</a></li>
</ul></div>
<pre class="math-block"><code>  \gdef\Set{\mathrm{\mathbf{Set}}}
  \gdef\Hask{\mathrm{\mathbf{Hask}}}
  \gdef\Vect{\mathrm{\mathbf{Vect}}}
  \gdef\Mon{\mathrm{\mathbf{Mon}}}
  \gdef\id{\mathrm{id}}
  \gdef\Id{\mathrm{Id}}
  \gdef\map{\mathrm{map}}
  \gdef\op#1{{#1}^{\mathrm{\scriptsize op}}}
  \gdef\listof#1{\left\lbrack{#1}\right\rbrack}</code></pre>
<h2 id="まえがき">まえがき</h2>
<p>先日、<a href="https://hackage.haskell.org/package/witherable-0.4.1/docs/Witherable.html">Witherable</a>
という型クラスについての理論的な面からの紹介を、Twitterにて投稿しました<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。
これをちゃんと記事にします。</p>
<h2 id="filterableとwitherable"><code>Filterable</code>と<code>Witherable</code></h2>
<p><code>witherable</code>パッケージでは、<code>Filterable</code>と<code>Witherable</code>という二つの型クラスが提供されています。
この2つのクラスはいったい何で、どういったことができるのか見ていきます。</p>
<h3 id="filterableの概要"><code>Filterable</code>の概要</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Witherable.hsより抜粋</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Filterable</span> f <span class="kw">where</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  mapMaybe f <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  catMaybes ::</span> f (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="ot">=</span> mapMaybe <span class="fu">id</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  filter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span> f <span class="ot">=</span> mapMaybe <span class="op">$</span> \a <span class="ot">-&gt;</span> <span class="kw">if</span> f a <span class="kw">then</span> <span class="dt">Just</span> a <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- mapMaybe か catMaybes のどちらか一方が必須</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL mapMaybe | catMaybes #-}</span></span></code></pre></div>
<p><code>Filterable</code>は、その名のとおり<code>filter</code>関数<code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>や、
<code>filter</code>より少し強力な機能を持つ<code>mapMaybe :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]</code>を、
リスト以外のコレクション型に一般化する型クラスです。
リストの<code>mapMaybe</code>が<code>map</code>の代わりにも<code>filter</code>の代わりにもなることを反映して、
<code>Filterable</code>なコレクション型はすべて<code>Functor</code>でもあることが求められています。
（つまり、<code>Filterable</code>の親クラスとして<code>Functor</code>があります。）</p>
<p>まずは<code>Filterable</code>のインスタンスにはどのようなものがあるのかを見てみましょう。
頻繁に使うコレクション型には、すでに（別の名前空間の下で）<code>mapMaybe</code>と名のつく関数があるので、
<code>Filterable</code>はその関数を使うだけです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> [] <span class="kw">where</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  mapMaybe <span class="ot">=</span> Data.Maybe.mapMaybe</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> <span class="dt">Vector</span> <span class="kw">where</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  mapMaybe <span class="ot">=</span> V.mapMaybe</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> (<span class="dt">Map</span> k) <span class="kw">where</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  mapMaybe <span class="ot">=</span> M.mapMaybe</span></code></pre></div>
<p>また、一見コレクション型には見えないものにも<code>mapMaybe</code>が適用できることがあります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Const</span>(<span class="dt">Const</span>(..))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | MaybeもFilterableになれる。「長さが0か1のリスト」とみなした場合に一致</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Filterable MaybeはMaybeモナドを使って定義できます！</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  mapMaybe <span class="ot">=</span> (<span class="op">=&lt;&lt;</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  catMaybes ::</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="ot">=</span> join</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- | (Const c)も「要素がゼロ個しか入らないコンテナ」としてFilterableになれる</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> (<span class="dt">Const</span> c) <span class="kw">where</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> c a <span class="ot">-&gt;</span> <span class="dt">Const</span> c b</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  mapMaybe _ (<span class="dt">Const</span> c) <span class="ot">=</span> <span class="dt">Const</span> c</span></code></pre></div>
<h3 id="witherableの概要"><code>Witherable</code>の概要</h3>
<p><code>Witherable</code>は、言うなれば「副作用のある<code>mapMaybe</code>」をするためのクラスで、
そのためのメソッド<code>wither</code>を持っています。以下に定義を示します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Traversable</span> t, <span class="dt">Filterable</span> t) <span class="ot">=&gt;</span> <span class="dt">Witherable</span> t <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  wither ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> b)) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 必須でないメソッドをいくつか省略</span></span></code></pre></div>
<p>例えば、次のような場合に<code>wither</code>が使えます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | 50%の確率で、ランダムに Just a か Nothing のどちらかを返す</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">coinToss ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | 50%の確率でランダムに要素を削除する</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">randomDrop ::</span> <span class="dt">Witherable</span> t <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">IO</span> (t a)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>randomDrop <span class="ot">=</span> wither coinToss</span></code></pre></div>
<p>これは、<code>Traversable</code>クラスが<code>Functor</code>クラスに対して、
「副作用のある<code>fmap</code>をする」とでも言うべき<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><code>traverse</code>メソッドを持っていることに似ています。
<code>Functor</code>、<code>Traversable</code>、<code>Filterable</code>と<code>Witherable</code>の関係を図にすると以下のようになります。</p>
<p><img src="../images/witherable-class-relation.svg" /></p>
<p>さて、<code>Witherable</code>が何をするクラスなのかを説明しましたが、
ここである疑問が湧いてきた方も居るかもしれません。</p>
<blockquote>
<p><code>Witherable</code>は<em>本当に必要なのか</em>？</p>
</blockquote>
<p>なぜかというと、あらゆる<code>Traversable</code>かつ<code>Filterable</code>なコレクション型に対して使える、
汎用の<code>wither</code>の定義があるからです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">witherDefault ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Filterable</span> t, <span class="dt">Applicative</span> f)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> b)) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>witherDefault f <span class="ot">=</span> <span class="fu">fmap</span> catMaybes <span class="op">.</span> <span class="fu">traverse</span> f</span></code></pre></div>
<p>もちろんHaskellのプログラムとしての効率（速度・メモリ使用）
の面からいって、各コレクション型に特化した<code>wither</code>を用いる意味があるため、
<code>Witherable</code>クラスの必要性は否定できません。しかし、
効率を無視して純粋に何ができるかだけ考えたときに、<code>Witherable</code>というクラスを設ける必要性はあるのでしょうか？
しかも、<code>Witherable</code>クラスには上記の<code>witherDefault</code>がデフォルトの実装として採用されており、
手動で書かないといけない関数は<strong>ひとつもありません</strong>。ますます疑念がわいてきます。</p>
<p>ですが、よくよく調べてみると、
<code>Witherable</code>は<code>Traversable + Filterable</code>とまったく同じではないことが分かります。
<code>witherDefault</code>は、どんな<code>Traversable</code>かつ<code>Filterable</code>な型<code>t</code>に対しても使えますが、
「<code>Witherable</code>の<code>wither</code>」には、<code>Witherable</code>則によって追加の保証がなされています。</p>
<p>つまり、<code>wither</code>が満たすべき性質を、<code>witherDefault</code>では保証できないことがあるのです。
次の節から、具体的にはどういうことなのか説明します。</p>
<h2 id="traversableのおさらい"><code>Traversable</code>のおさらい</h2>
<p>準備として、<code>Traversable</code>クラスと、その<code>Traversable</code>則についておさらいしておきます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# MINIMAL traverse | sequenceA #-}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">traverse</span> f <span class="ot">=</span> <span class="fu">sequenceA</span> <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    sequenceA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sequenceA</span> <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span></code></pre></div>
<p><code>Traversable</code>は、<code>traverse</code>または<code>sequenceA</code>のどちらかを与えることで定義できます。
どちらを基準にしてもよいのですが、ここでは<code>sequenceA</code>の方で定義されているとしましょう。
<code>sequenceA</code>は「<code>t</code>と<code>f</code>の合成関手の間の自然変換」という型を持つため、以下のようにストリング図<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>で表現しやすいのです。</p>
<figure>
<img src="../images/witherable/traversable.png" alt="sequenceAのストリング図での描き方" />
<figcaption aria-hidden="true"><code>sequenceA</code>のストリング図での描き方</figcaption>
</figure>
<p>図を見やすくするため、この記事を通して、
ストリング図中では<code>sequenceA</code>のことをギリシャ文字デルタ(<span class="math inline">\delta</span>)一文字で表記することにします。
また、本来は小文字で書いていた<code>t</code>や<code>f</code>といった関手の名前も、大文字で<span class="math inline">T</span>のように書いてしまいます。</p>
<p><code>Traversable</code>則を定義するやりかたはいくつかありますが、
標準ライブラリのドキュメント<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Traversable.html#laws">Data.Traversable</a>
における定義がそのままで便利です。</p>
<dl>
<dt>
Naturality
</dt>
<dd>
全てのアプリカティブ準同型<code>t</code>に対して
<code>t . sequenceA = sequenceA . fmap t</code>
</dd>
<dt>
Identity
</dt>
<dd>
<code>sequenceA . fmap Identity = Identity</code>
</dd>
<dt>
Composition
<dt>
<dd>
<code>sequenceA . fmap Compose = Compose . fmap sequenceA . sequenceA</code>
</dd>
</dl>
<p>ここで、アプリカティブ準同型とは、以下の関数</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">t ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>で、アプリカティブの演算を保つものです。つまり以下の等式が成り立ちます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>t (<span class="fu">pure</span> x) <span class="ot">=</span> <span class="fu">pure</span> x</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>t (f <span class="op">&lt;*&gt;</span> x) <span class="ot">=</span> t f <span class="op">&lt;*&gt;</span> t x</span></code></pre></div>
<p>また、恒等関手<code>Identity</code>と関手の合成<code>Compose</code>はそれぞれ
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Functor-Identity.html">Data.Functor.Identity</a>と
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Functor-Identity.html">Data.Functor.Compose</a>です。</p>
<p>これをストリング図に描いたものが以下になります。</p>
<figure>
<img src="../images/witherable/traversable-laws-1.png" alt="Traversable則NaturalityとIdentity" />
<figcaption aria-hidden="true">Traversable則NaturalityとIdentity</figcaption>
</figure>
<figure>
<img src="../images/witherable/traversable-laws-2.png" alt="Traversable則Composition" />
<figcaption aria-hidden="true">Traversable則Composition</figcaption>
</figure>
<h2 id="filterableの理論"><code>Filterable</code>の理論</h2>
<p><code>Filterable</code>は「<code>mapMaybe</code>に似ている関数」をまとめたものでした。
しかし、<code>(a -&gt; Maybe b) -&gt; t a -&gt; t b</code>という型をした関数を何でも<code>mapMaybe</code>に当てはめていいとすると、
それが本当にリストとの類推ができるような操作なのかは分かりません。
そこで、<code>Functor</code>則や<code>Applicative</code>則のように、<code>Filterable</code>則が決められています。</p>
<dl>
<dt>
Conservation（保存則）
</dt>
<dd>
<code>mapMaybe (Just . f) = fmap f</code>
</dd>
<dt>
Composition（合成則）
</dt>
<dd>
<code>mapMaybe f . mapMaybe g = mapMaybe (f &lt;=&lt; g)</code>
</dd>
</dl>
<p>ストリング図への描きやすさから、<code>Filterable</code>則を<code>mapMaybe</code>の代わりに<code>catMaybes</code>で表現し直しておきます。
まず、<code>mapMaybe</code>と<code>catMaybes</code>は互いに定義可能でした。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (再掲)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Filterable</span> f <span class="kw">where</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  mapMaybe f <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  catMaybes ::</span> f (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="ot">=</span> mapMaybe <span class="fu">id</span></span></code></pre></div>
<p><code>catMaybes</code>で表現した<code>Filterable</code>則は以下のようになります。
これが実際に<code>mapMaybe</code>での表現と同値であることは各自お確かめ下さい。</p>
<dl>
<dt>
Identity(単位則)
</dt>
<dd>
<code>catMaybes . fmap Just = id</code>
</dd>
<dd>
<dt>
Composition(合成則)
</dt>
<dd>
<p><code>catMaybes . catMaybes = catMaybes . fmap join</code></p>
ここで<code>join</code>は<code>Maybe</code>の<code>Monad</code>演算<code>join :: Maybe (Maybe a) -&gt; Maybe a</code>
</dd>
</dl>
<p>これをストリング図に書くと以下のようになります。</p>
<figure>
<img src="../images/witherable/filterable.png" alt="catMaybesで表現したFilterable" />
<figcaption aria-hidden="true"><code>catMaybes</code>で表現した<code>Filterable</code></figcaption>
</figure>
<p>ただし、<code>sequenceA</code>を描くときに<span class="math inline">\delta</span>一文字に略したように、
ストリング図中では次の記法を使うことにします。</p>
<ul>
<li><code>Maybe</code>は<span class="math inline">P</span>と略します。</li>
<li><code>catMaybes :: t (Maybe a) -&gt; t a</code>は、3本の線（上に<span class="math inline">P</span>と<span class="math inline">T</span>、下に<span class="math inline">T</span>）が出ている○で表します。</li>
</ul>
<figure>
<img src="../images/witherable/filterable-laws.png" alt="Filterable則" />
<figcaption aria-hidden="true"><code>Filterable</code>則</figcaption>
</figure>
<h3 id="脱法filterable">脱法<code>Filterable</code></h3>
<p><code>Filterable</code>則の定式化は単純で理論的にもきれいです<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。しかし、
<code>Filterable</code>という名前からは少し意外な振る舞いをするインスタンスも存在します。
例えば、次の<code>U</code>型は、0個か2個の要素を持つコンテナ型で、
2個の要素のうち片方が<code>Nothing</code>になると、もう片方も”連帯責任”で削除されてしまいます。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">U</span> a <span class="ot">=</span> <span class="dt">U0</span> <span class="op">|</span> <span class="dt">U2</span> a a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- DeriveTraversable拡張を使用</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> <span class="dt">U</span> <span class="kw">where</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  catMaybes ::</span> <span class="dt">U</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">U</span> a</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  catMaybes (<span class="dt">U2</span> (<span class="dt">Just</span> x) (<span class="dt">Just</span> y)) <span class="ot">=</span> <span class="dt">U2</span> x y</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  catMaybes _                      <span class="ot">=</span> <span class="dt">U0</span></span></code></pre></div>
<p>このような変なふるまいをする<code>catMaybes</code>でも、<code>Filterable</code>則を満たすれっきとしたインスタンスです。</p>
<ul>
<li><p>Identity <code>catMaybes . fmap Just = id</code></p>
<details>
<p><code>ua :: U a</code>としたとき、<code>catMaybes . fmap Just $ ua = ua</code>を確認する。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ua = U0 の場合</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">U0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">U0</span> <span class="ot">=</span> <span class="dt">U0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ua = U2 x y の場合</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">U2</span> x y</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> (<span class="dt">Just</span> x) (<span class="dt">Just</span> y)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">U2</span> x y</span></code></pre></div>
</details></li>
<li><p>Composition <code>catMaybes . catMaybes = catMaybes . fmap join</code></p>
<details>
<p><code>umma :: U (Maybe (Maybe a))</code>としたとき、<code>catMaybes (catMaybes umma) = catMaybes (fmap join umma)</code>を確認する。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- umma = U0 の場合</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">U0</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">U0</span> <span class="ot">=</span> <span class="dt">U0</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">U0</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">U0</span> <span class="ot">=</span> <span class="dt">U0</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- umma = U2 mmx mmy</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">--   mmx = Just mx, mmy = Just my の場合</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> (<span class="dt">Just</span> mx) (<span class="dt">Just</span> my)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> mx my</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">U2</span> (<span class="dt">Just</span> mx) (<span class="dt">Just</span> my)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> (join (<span class="dt">Just</span> mx)) (join (<span class="dt">Just</span> my))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> mx my</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">--   mmx, mmyのどちらかがNothingの場合</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> mmx mmy</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> catMaybes <span class="dt">U0</span> <span class="ot">=</span> <span class="dt">U0</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">U2</span> mmx mmy</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">U2</span> (join mmx) (join mmy)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">{- join mmx, join mmyのどちらかはNothingなので -}</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">U0</span></span></code></pre></div>
</details></li>
</ul>
<p>また違った振る舞いのインスタンスも定義できます。
今度は、2要素のうち片方だけが<code>Nothing</code>になると、もう片方の要素をコピーして2要素を保ちます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">V</span> a <span class="ot">=</span> <span class="dt">V0</span> <span class="op">|</span> <span class="dt">V2</span> a a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- DeriveTraversable拡張を使用</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Filterable</span> <span class="dt">V</span> <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  catMaybes ::</span> <span class="dt">V</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">V</span> a</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  catMaybes <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  catMaybes (<span class="dt">V2</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>) <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  catMaybes (<span class="dt">V2</span> <span class="dt">Nothing</span> (<span class="dt">Just</span> y)) <span class="ot">=</span> <span class="dt">V2</span> y y</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  catMaybes (<span class="dt">V2</span> (<span class="dt">Just</span> x) <span class="dt">Nothing</span>) <span class="ot">=</span> <span class="dt">V2</span> x x</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  catMaybes (<span class="dt">V2</span> (<span class="dt">Just</span> x) (<span class="dt">Just</span> y)) <span class="ot">=</span> <span class="dt">V2</span> x y</span></code></pre></div>
<ul>
<li><p>Identity <code>catMaybes . fmap Just = id</code></p>
<details>
<p><code>va :: V a</code>としたとき、<code>catMaybes . fmap Just $ va = va</code>を確認する。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- va = V0 の場合</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">V0</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- va = V2 x y の場合</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">V2</span> x y</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> (<span class="dt">Just</span> x) (<span class="dt">Just</span> y)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">V2</span> x y</span></code></pre></div>
</details></li>
<li><p>Composition <code>catMaybes . catMaybes = catMaybes . fmap join</code></p>
<details>
<p><code>vmma :: V (Maybe (Maybe a))</code>としたとき、<code>catMaybes (catMaybes vmma) = catMaybes (fmap join vmma)</code>を確認する。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- vmma = V0 の場合</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">V0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">V0</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- vmma = V2 Nothing Nothing の場合</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">V2</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- vmma = V2 (Just mx) (Just my) の場合</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> (<span class="dt">Just</span> mx) (<span class="dt">Just</span> my)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> mx my</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">V2</span> (<span class="dt">Just</span> mx) (<span class="dt">Just</span> my)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> mx my</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- vmma = V2 (Just mx) Nothing の場合</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> (<span class="dt">Just</span> mx) <span class="dt">Nothing</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> mx mx</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>catMaybes <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> <span class="dt">V2</span> (<span class="dt">Just</span> mx) <span class="dt">Nothing</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="dt">V2</span> mx <span class="dt">Nothing</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ここで mx で場合分けする</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">--   Nothing -&gt; 両辺ともV0</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">--   Just x  -&gt; 両辺ともV2 x x</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- vmma = V2 Nothing (Just my) の場合も</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- xとyを入れ替えただけで同様</span></span></code></pre></div>
</details></li>
</ul>
<p>こうした奇妙なインスタンスが禁止されるような、より厳しい法則は考えられないでしょうか？
実は、<code>Filterable</code>だけを使ってもうまくいきません<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。
そのため、<code>Foldable</code>や<code>Traversable</code>の機能をも使って、厳しい法則を定めてみましょう。</p>
<p>上記の<code>U</code>や<code>V</code>が<code>catMaybes</code>として「ふさわしくない感じがする」理由の一つとして、
存在する要素の個数が<code>catMaybes</code>によって変わってしまうという点がありそうです。
この「要素の個数」というのは<code>Foldable</code>の機能です。「要素の個数が変わらない」を定式化してみましょう<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Filterableのより強い法則（候補1）:</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>length' <span class="op">.</span> catMaybes <span class="ot">=</span> countJusts</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Int の代わりに Sum Int を返す length</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    length' ::</span> (<span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    length' <span class="ot">=</span> <span class="dt">Sum</span> <span class="op">.</span> <span class="fu">length</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=</span> <span class="fu">foldMap</span> (<span class="fu">const</span> <span class="dv">1</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    countJusts ::</span> (<span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    countJusts <span class="ot">=</span> <span class="fu">foldMap</span> length' <span class="co">-- このlength' は Maybe a -&gt; Sum Int</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>                                <span class="co">-- (Justなら1, Nothingなら0)</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- 補助的な関数を使わずに書くなら：</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> (<span class="fu">const</span> <span class="dv">1</span>) <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">foldMap</span> (<span class="fu">foldMap</span> (<span class="fu">const</span> <span class="dv">1</span>))</span></code></pre></div>
<p><code>U</code>も<code>V</code>もこの法則候補1を満たすことができませんね！
もう少し強い要請として、「要素だけをリストに取り出したもの」が<code>catMaybes</code>によって変わらない、というものも考えられます。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Filterableのより強い法則（候補2）:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>toList <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">concatMap</span><span class="ot"> toList ::</span> t (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- concatMapもtoListもfoldMapの特別な場合です。</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   concatMap = foldMap :: (Foldable t) =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">--   toList = foldMap singleton</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">--     where singleton a = [a]</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 代入して foldMap だけで表現すると以下のようになります。</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> singleton <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">foldMap</span> (<span class="fu">foldMap</span> singleton)</span></code></pre></div>
<p>これらを統合して、<code>foldMap</code>が<code>catMaybes</code>で変わらない、としてもよいでしょう。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Filterableのより強い法則（候補3）:</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> f <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">foldMap</span> (<span class="fu">foldMap</span> f)</span></code></pre></div>
<p>今考えている<code>Filterable</code>なコンテナ型は<code>Functor</code>でもありました。
ここではさらに<code>Foldable</code>でもあるものを考えています。
<code>Functor</code>かつ<code>Foldable</code>ならば、
その両方を親クラスに持つ<code>Traversable</code>であってもおかしくないでしょう<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>。
<code>foldMap</code>が<code>traverse</code>/<code>sequenceA</code>で実装できることを思い出すと、
（候補3）の<code>Traversable</code>版は以下のようになります。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Filterableのより強い法則：</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span> f <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">fmap</span> catMaybes <span class="op">.</span> <span class="fu">traverse</span> (<span class="fu">traverse</span> f)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- sequenceAで表現するならば：</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sequenceA</span> <span class="op">.</span> catMaybes <span class="ot">=</span> <span class="fu">fmap</span> catMaybes <span class="op">.</span> <span class="fu">sequenceA</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">sequenceA</span></span></code></pre></div>
<p>この法則には<strong>Distributivity</strong>という名前を付けることにします。
Distributivityから（候補1）〜（候補3）が導けるので、
<code>U</code>や<code>V</code>は<code>Filterable</code>かつ<code>Traversable</code>でありながら、
Distributivityを満たさないような具体例となっています。</p>
<p>絵も描いておきます。</p>
<figure>
<img src="../images/witherable/distributivity.png" alt="Distributivity" />
<figcaption aria-hidden="true">Distributivity</figcaption>
</figure>
<p>ただし、これまでの略記法</p>
<ul>
<li><code>Maybe</code>を<span class="math inline">P</span>と書く</li>
<li><code>catMaybes</code>を○で表す</li>
<li><code>sequenceA</code>を<span class="math inline">\delta</span>と書く</li>
</ul>
<p>をフル活用しています。<span class="math inline">\delta_P</span>は<code>Maybe</code>に対する<code>sequenceA</code>のことです。</p>
<h2 id="witherableの理論"><code>Witherable</code>の理論</h2>
<p>この記事のはじめのほうで<code>Witherable</code>の定義と使い方を説明し、「<code>Witherable</code>は<code>Filterable</code>と<code>Traversable</code>の組み合わせに過ぎないのではないか？」という疑問を取り上げました。
繰り返しになりますが、実は<code>Witherable</code>は<code>Filterable</code>+<code>Traversable</code>より厳しい制限が課せられているのです。この制限は<code>Witherable</code>則として表されています。</p>
<p><code>Witherable</code>の定義を再掲します。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Traversable</span> t, <span class="dt">Filterable</span> t) <span class="ot">=&gt;</span> <span class="dt">Witherable</span> t <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  wither ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> b)) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span></code></pre></div>
<p><code>Witherable</code>則は<code>wither</code>を使って記述されていますが、
今後の事情のために（<code>traverse</code>に対して<code>sequenceA</code>を使ったように）以下の
<span class="math inline">\omega</span>という関数を代わりに使うことにします。
<span class="math inline">\omega</span>から<code>wither</code>を、逆に<code>wither</code>から<span class="math inline">\omega</span>を定義できるので、どちらを使ってもいいはずです。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ω<span class="ot"> ::</span> (<span class="dt">Witherable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> t (f (<span class="dt">Maybe</span> a)) <span class="ot">-&gt;</span> f (t a)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>ω <span class="ot">=</span> wither <span class="fu">id</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">wither ::</span> (<span class="dt">Witherable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> b)) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>wither f <span class="ot">=</span> ω <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p>これをストリング図に描くと以下のようになります。</p>
<figure>
<img src="../images/witherable/witherable.png" alt="Witherableの定義" />
<figcaption aria-hidden="true">Witherableの定義</figcaption>
</figure>
<p><span class="math inline">\omega</span>を使った<code>Witherable</code>則は以下のようになります。</p>
<dl>
<dt>
Naturality(自然性)
</dt>
<dd>
<p>全てのアプリカティブ準同型<code>t</code>に対して</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>  t <span class="op">.</span> ω <span class="ot">=</span> ω <span class="op">.</span> <span class="fu">fmap</span> t</span></code></pre></div>
<figure>
<img src="../images/witherable/witherable-naturality.png" alt="Witherable則Naturality" />
<figcaption aria-hidden="true">Witherable則Naturality</figcaption>
</figure>
</dd>
<dt>
Identity(単位則)
</dt>
<dd>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>  ω <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Identity</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Just</span> <span class="ot">=</span> <span class="dt">Identity</span></span></code></pre></div>
<figure>
<img src="../images/witherable/witherable-identity.png" alt="Witherable則Identity" />
<figcaption aria-hidden="true">Witherable則Identity</figcaption>
</figure>
</dd>
<dd>
<dt>
Composition(合成則)
</dt>
<dd>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span> <span class="op">.</span> <span class="fu">fmap</span> ω <span class="op">.</span> ω <span class="ot">=</span> ω <span class="op">.</span> <span class="fu">fmap</span> (<span class="dt">Compose</span> <span class="op">.</span> <span class="fu">fmap</span> ω_P)</span></code></pre></div>
<figure>
<img src="../images/witherable/witherable-composition.png" alt="Witherable則Composition" />
<figcaption aria-hidden="true">Witherable則Composition</figcaption>
</figure>
<p>ただし、<span class="math inline">\omega_P</span>は<code>Maybe</code>に対する<span class="math inline">\omega</span>で、
以下のように定義される。</p>
<figure>
<img src="../images/witherable/witherable-maybe.png" alt="Witherable Maybe" />
<figcaption aria-hidden="true">Witherable Maybe</figcaption>
</figure>
</dd>
</dl>
<h2 id="witherable-は-filterabletraversable-ではない">Witherable は Filterable+Traversable ではない</h2>
<p><code>Witherable</code>とその法則は上記のように定義されています。
このとき、<code>Witherable t</code>は<code>Filterable t</code>かつ<code>Traversable t</code><strong>かつ<code>t</code>がDistributivityを満たす</strong>ことと同値になることが証明できます。
（Distributivityが本当に追加の条件であって<code>Filterable</code>則や<code>Traversable</code>則から導けないことは、上記の<code>U</code>や<code>V</code>が存在することからわかります。）</p>
<p>次の<code>catMaybesDefault</code>によって、
<code>Witherable</code>は<code>Filterable</code>の機能を併せ持つ上位互換であることがわかります。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">catMaybesDefault ::</span> <span class="dt">Witherable</span> t <span class="ot">=&gt;</span> t (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> t a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>catMaybesDefault <span class="ot">=</span> runIdentity <span class="op">.</span> ω <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Identity</span></span></code></pre></div>
<figure>
<img src="../images/witherable/to-filterable.png" alt="WitherableはFilterableの機能を含む" />
<figcaption aria-hidden="true">WitherableはFilterableの機能を含む</figcaption>
</figure>
<p><code>Filterable</code>則も<code>Witherable</code>則から証明できます。</p>
<details>
<summary>
Identity(単位則)
</summary>
<img src="../images/witherable/to-filterable-ident.png" />
</details>
<details>
<summary>
Composition(合成則)
</summary>
<img src="../images/witherable/to-filterable-comp.png" />
</details>
<p>同じように<code>Witherable</code>は<code>Traversable</code>の機能も併せ持ち、
<code>Traversable</code>則は<code>Witherable</code>則から証明できます。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceADefault ::</span> (<span class="dt">Witherable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>sequenceADefault <span class="ot">=</span> ω <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> <span class="dt">Just</span>)</span></code></pre></div>
<figure>
<img src="../images/witherable/to-traversable.png" alt="WitherableはTraversableの機能を含む" />
<figcaption aria-hidden="true">WitherableはTraversableの機能を含む</figcaption>
</figure>
<details>
<summary>
Naturality(自然性)
</summary>
<img src="../images/witherable/to-traversable-nat.png" />
</details>
<details>
<summary>
Identity(単位則)
</summary>
<img src="../images/witherable/to-traversable-ident.png" />
</details>
<details>
<summary>
Composition(合成則)
</summary>
<img src="../images/witherable/to-traversable-comp.png" />
</details>
<p>さらに、<code>catMaybesDefault</code>と<code>sequenceADefault</code>の2つから、
<span class="math inline">ω</span>を復元できます。</p>
<details>
<summary>
<code>ω = fmap catMaybes . sequenceA</code>
</summary>
<figure>
<img src="../images/witherable/canonicity.png" alt="Canonicity" />
<figcaption aria-hidden="true">Canonicity</figcaption>
</figure>
</details>
<p>そして最後に、<code>Witherable</code>から取り出した<code>Filterable</code>と<code>Traversable</code>は、
Distributivity――先程定義した、「変な」<code>Filterable</code>を除外する法則――を満たすことが証明できます。</p>
<details>
<summary>
証明
</summary>
<figure>
<img src="../images/witherable/to-distributivity.png" alt="DistributivityはWitherable則から導ける" />
<figcaption aria-hidden="true">DistributivityはWitherable則から導ける</figcaption>
</figure>
</details>
<p>つまり、<code>Witherable</code>は少なくとも<code>Filterable</code>かつ<code>Traversable</code><strong>かつDistributivityをもつ</strong>ような型クラスです。</p>
<p><img src="../images/witherable/from-witherable.png" /></p>
<p>逆に、<code>Filterable</code>かつ<code>Traversable</code>かつDistibutivityをもつならば、<code>witherDefault</code>が<code>Witherable</code>則を満たすことも示せ、結果として同値性が分かります。</p>
<p><img src="../images/witherable/to-witherable.png" /></p>
<details>
<summary>
証明
</summary>
<img src="../images/witherable/to-witherable-laws.png" />
</details>
<h2 id="結論">結論</h2>
<p><code>Witherable</code>は<code>Filterable</code>と<code>Traversable</code>の両方の機能をもち、この2クラスに「脱法<code>Filterable</code>封じの<code>Distributivity</code>則」を合わせたものと同値で、
それを<code>wither</code>と3つの<code>Witherable</code>則で表したものでした！</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://twitter.com/viercc/status/1445571167591403524">https://twitter.com/viercc/status/1445571167591403524</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>人によっては、副作用のある<code>fmap</code>と言ったら
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Traversable.html#v:mapM">mapM</a>の方を思い出すかもしれません。
実のところ<code>traverse</code>と<code>mapM</code>は兄弟みたいなものです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot">     ::</span>                  (a <span class="ot">-&gt;</span> b)   <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span>    t b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot">     ::</span> <span class="dt">Monad</span> m       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span></code></pre></div>
<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn3"><p><a href="./2021-05-17-string-diagram.html">ストリング図の説明をした過去記事</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><code>Filterable f</code>は、簡潔に「<code>f</code>は<code>Kleisli Maybe</code>から<code>-&gt;</code>への関手である」
と表現されることもあり、<code>Filterable</code>則は関手の従うべき単位則と合成則を言い直したものに相当します。
今回の記事とはあまり関係しない論点ですが、過去の投稿で何度か触れております：
<a href="./2018-12-29-about-align.html">型クラスAlignについて</a>
<a href="2021-06-24-monads-from-adjunction.html">随伴から作られるMonad(準備編)</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>某所で議論があり、「うまくいかない」というのは技術的に微妙なポイントなのですが、
あまり整理されていないかつ口論が混じっている会話なのでリンクはしません<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><code>Sum</code> は <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Monoid.html#t:Sum">Data.Monoid</a> にあります<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><code>Foldable</code>には法則がないので、可能なら<code>Traversable</code>を使いたいのです<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
